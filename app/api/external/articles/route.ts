import { NextRequest, NextResponse } from "next/server"
import { prisma } from "@/lib/prisma"
import { validateApiKey, hasPermission, corsHeaders } from "@/lib/api-auth"

export async function OPTIONS() {
  return NextResponse.json({}, { headers: corsHeaders() })
}

/**
 * GET /api/external/articles
 * Returns articles for external stores
 * Query params:
 *   - slug: filter by slug
 *   - id: filter by ID
 *   - status: filter by status (default: PUBLISHED)
 *   - category: filter by category
 *   - locale: filter by locale
 *   - limit: number of articles (default: 10, max: 50)
 *   - page: page number for pagination
 *   - tag: filter by tag
 */
export async function GET(request: NextRequest) {
  const headers = corsHeaders(request.headers.get("origin") || undefined)

  // Validate API key
  const validation = await validateApiKey(request)

  if (!validation.isValid) {
    return NextResponse.json(
      { error: validation.error },
      { status: 401, headers }
    )
  }

  if (!hasPermission(validation.apiKey!.permissions, "read")) {
    return NextResponse.json(
      { error: "Missing required permission: read" },
      { status: 403, headers }
    )
  }

  try {
    const { searchParams } = new URL(request.url)
    const slug = searchParams.get("slug")
    const id = searchParams.get("id")
    const status = searchParams.get("status") || "PUBLISHED"
    const category = searchParams.get("category")
    const locale = searchParams.get("locale")
    const tag = searchParams.get("tag")
    const limit = Math.min(parseInt(searchParams.get("limit") || "10"), 50)
    const page = parseInt(searchParams.get("page") || "1")
    const skip = (page - 1) * limit

    // Build where clause
    const where: Record<string, unknown> = {}

    // If fetching by slug or id, don't filter by status (allow fetching drafts for CMS)
    if (slug) {
      where.slug = slug
    } else if (id) {
      where.id = id
    } else {
      // Only filter by status when listing articles
      where.status = status
    }

    if (category) {
      where.category = category
    }

    if (locale) {
      where.locale = locale
    }

    if (tag) {
      where.tags = {
        has: tag,
      }
    }

    // Get total count for pagination
    const totalCount = await prisma.article.count({ where })

    // Fetch articles
    const articles = await prisma.article.findMany({
      where,
      orderBy: [
        { publishedAt: "desc" },
        { createdAt: "desc" },
      ],
      skip,
      take: limit,
    })

    // Transform articles to external format
    const externalArticles = articles.map((article) => ({
      id: article.id,
      slug: article.slug,
      title: article.title,
      excerpt: article.excerpt,
      content: article.content,
      coverImage: article.coverImage,
      author: article.author,
      authorAvatar: article.authorAvatar,
      category: article.category,
      tags: article.tags,
      status: article.status,
      publishedAt: article.publishedAt?.toISOString() || null,
      scheduledAt: article.scheduledAt?.toISOString() || null,
      readingTime: article.readingTime,
      views: article.views,
      locale: article.locale,
      seoTitle: article.seoTitle,
      seoDescription: article.seoDescription,
      isAutogenerated: article.isAutogenerated,
      sourceType: article.sourceType,
      createdAt: article.createdAt.toISOString(),
      updatedAt: article.updatedAt.toISOString(),
    }))

    return NextResponse.json({
      success: true,
      articles: externalArticles,
      count: externalArticles.length,
      totalCount,
      totalPages: Math.ceil(totalCount / limit),
      currentPage: page,
    }, { headers })
  } catch (error) {
    console.error("Error fetching articles:", error)
    return NextResponse.json(
      { error: "Failed to fetch articles" },
      { status: 500, headers }
    )
  }
}

/**
 * POST /api/external/articles
 * Create a new article (for autoblogging)
 */
export async function POST(request: NextRequest) {
  const headers = corsHeaders(request.headers.get("origin") || undefined)

  // Validate API key
  const validation = await validateApiKey(request)

  if (!validation.isValid) {
    return NextResponse.json(
      { error: validation.error },
      { status: 401, headers }
    )
  }

  if (!hasPermission(validation.apiKey!.permissions, "write")) {
    return NextResponse.json(
      { error: "Missing required permission: write" },
      { status: 403, headers }
    )
  }

  try {
    const body = await request.json()
    const {
      title,
      slug,
      excerpt,
      content,
      coverImage,
      author,
      authorAvatar,
      category,
      tags,
      status,
      scheduledAt,
      locale,
      seoTitle,
      seoDescription,
      isAutogenerated,
      sourceUrl,
      sourceType,
    } = body

    // Validate required fields
    if (!title || !content) {
      return NextResponse.json(
        { error: "Title and content are required" },
        { status: 400, headers }
      )
    }

    // Generate slug if not provided
    const articleSlug = slug || generateSlug(title)

    // Check if slug already exists
    const existingArticle = await prisma.article.findUnique({
      where: { slug: articleSlug },
    })

    if (existingArticle) {
      return NextResponse.json(
        { error: "An article with this slug already exists" },
        { status: 409, headers }
      )
    }

    // Calculate reading time (rough estimate: 200 words per minute)
    const wordCount = content.split(/\s+/).length
    const readingTime = Math.max(1, Math.ceil(wordCount / 200))

    // Create article
    const article = await prisma.article.create({
      data: {
        title,
        slug: articleSlug,
        excerpt: excerpt || null,
        content,
        coverImage: coverImage || null,
        author: author || "Techavor Team",
        authorAvatar: authorAvatar || null,
        category: category || "cybersecurity",
        tags: tags || [],
        status: status || "DRAFT",
        scheduledAt: scheduledAt ? new Date(scheduledAt) : null,
        publishedAt: status === "PUBLISHED" ? new Date() : null,
        locale: locale || "en",
        seoTitle: seoTitle || null,
        seoDescription: seoDescription || null,
        readingTime,
        isAutogenerated: isAutogenerated || false,
        sourceUrl: sourceUrl || null,
        sourceType: sourceType || null,
      },
    })

    return NextResponse.json({
      success: true,
      article: {
        id: article.id,
        slug: article.slug,
        title: article.title,
        status: article.status,
        createdAt: article.createdAt.toISOString(),
      },
    }, { status: 201, headers })
  } catch (error) {
    console.error("Error creating article:", error)
    return NextResponse.json(
      { error: "Failed to create article" },
      { status: 500, headers }
    )
  }
}

/**
 * PUT /api/external/articles
 * Update an existing article
 */
export async function PUT(request: NextRequest) {
  const headers = corsHeaders(request.headers.get("origin") || undefined)

  // Validate API key
  const validation = await validateApiKey(request)

  if (!validation.isValid) {
    return NextResponse.json(
      { error: validation.error },
      { status: 401, headers }
    )
  }

  if (!hasPermission(validation.apiKey!.permissions, "write")) {
    return NextResponse.json(
      { error: "Missing required permission: write" },
      { status: 403, headers }
    )
  }

  try {
    const body = await request.json()
    const { id, ...updateData } = body

    if (!id) {
      return NextResponse.json(
        { error: "Article ID is required" },
        { status: 400, headers }
      )
    }

    // Check if article exists
    const existingArticle = await prisma.article.findUnique({
      where: { id },
    })

    if (!existingArticle) {
      return NextResponse.json(
        { error: "Article not found" },
        { status: 404, headers }
      )
    }

    // Handle status change to PUBLISHED
    const dataToUpdate: Record<string, unknown> = {}

    if (updateData.title !== undefined) dataToUpdate.title = updateData.title
    if (updateData.slug !== undefined) dataToUpdate.slug = updateData.slug
    if (updateData.excerpt !== undefined) dataToUpdate.excerpt = updateData.excerpt
    if (updateData.content !== undefined) {
      dataToUpdate.content = updateData.content
      // Recalculate reading time
      const wordCount = updateData.content.split(/\s+/).length
      dataToUpdate.readingTime = Math.max(1, Math.ceil(wordCount / 200))
    }
    if (updateData.coverImage !== undefined) dataToUpdate.coverImage = updateData.coverImage
    if (updateData.author !== undefined) dataToUpdate.author = updateData.author
    if (updateData.authorAvatar !== undefined) dataToUpdate.authorAvatar = updateData.authorAvatar
    if (updateData.category !== undefined) dataToUpdate.category = updateData.category
    if (updateData.tags !== undefined) dataToUpdate.tags = updateData.tags
    if (updateData.status !== undefined) {
      dataToUpdate.status = updateData.status
      // Set publishedAt if publishing for the first time
      if (updateData.status === "PUBLISHED" && !existingArticle.publishedAt) {
        dataToUpdate.publishedAt = new Date()
      }
    }
    if (updateData.scheduledAt !== undefined) {
      dataToUpdate.scheduledAt = updateData.scheduledAt ? new Date(updateData.scheduledAt) : null
    }
    if (updateData.locale !== undefined) dataToUpdate.locale = updateData.locale
    if (updateData.seoTitle !== undefined) dataToUpdate.seoTitle = updateData.seoTitle
    if (updateData.seoDescription !== undefined) dataToUpdate.seoDescription = updateData.seoDescription

    // Update article
    const article = await prisma.article.update({
      where: { id },
      data: dataToUpdate,
    })

    return NextResponse.json({
      success: true,
      article: {
        id: article.id,
        slug: article.slug,
        title: article.title,
        status: article.status,
        updatedAt: article.updatedAt.toISOString(),
      },
    }, { headers })
  } catch (error) {
    console.error("Error updating article:", error)
    return NextResponse.json(
      { error: "Failed to update article" },
      { status: 500, headers }
    )
  }
}

/**
 * DELETE /api/external/articles
 * Delete an article
 */
export async function DELETE(request: NextRequest) {
  const headers = corsHeaders(request.headers.get("origin") || undefined)

  // Validate API key
  const validation = await validateApiKey(request)

  if (!validation.isValid) {
    return NextResponse.json(
      { error: validation.error },
      { status: 401, headers }
    )
  }

  if (!hasPermission(validation.apiKey!.permissions, "write")) {
    return NextResponse.json(
      { error: "Missing required permission: write" },
      { status: 403, headers }
    )
  }

  try {
    const { searchParams } = new URL(request.url)
    const id = searchParams.get("id")

    if (!id) {
      return NextResponse.json(
        { error: "Article ID is required" },
        { status: 400, headers }
      )
    }

    // Check if article exists
    const existingArticle = await prisma.article.findUnique({
      where: { id },
    })

    if (!existingArticle) {
      return NextResponse.json(
        { error: "Article not found" },
        { status: 404, headers }
      )
    }

    // Delete article
    await prisma.article.delete({
      where: { id },
    })

    return NextResponse.json({
      success: true,
      message: "Article deleted successfully",
    }, { headers })
  } catch (error) {
    console.error("Error deleting article:", error)
    return NextResponse.json(
      { error: "Failed to delete article" },
      { status: 500, headers }
    )
  }
}

/**
 * Generate a URL-friendly slug from a title
 */
function generateSlug(title: string): string {
  return title
    .toLowerCase()
    .replace(/[^\w\s-]/g, "") // Remove special characters
    .replace(/\s+/g, "-") // Replace spaces with hyphens
    .replace(/--+/g, "-") // Replace multiple hyphens with single
    .replace(/^-+/, "") // Remove leading hyphens
    .replace(/-+$/, "") // Remove trailing hyphens
    .substring(0, 100) // Limit length
    + "-" + Date.now().toString(36) // Add unique suffix
}
